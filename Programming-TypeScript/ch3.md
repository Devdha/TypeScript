# 타입의 모든 것

### 타입

`값과 이 값으로 할 수 있는 일의 집합`

- number 타입은 모든 숫자와 숫자에 적용할 수 있는 연산과 메서드의 집합
- string 타입은 모든 문자열과 문자열에 수행할 수 있는 모든 연산과 메서드의 집합

C++에서 타입을 클래스로 선언하고 연산과 메서드를 포함하는 형태와 비슷한 것 같다.

타입에서 중요한 점은 타입 검사기를 통해 유효하지 않은 동작의 실행을 예방하는 것이다.

<img width="501" alt="Screen Shot 2023-04-13 at 11 16 59 PM" src="https://user-images.githubusercontent.com/46529663/231787701-2115d4dd-15b1-473e-9e68-73c8ecfcb4ee.png">

## 타입의 가나다

### any

any 타입은 모든 타입을 아우르는 역할을 한다.
하지만, any 타입은 꼭 필요하지 않다면 사용하지 않는 것이 좋다.

프로그래머와 타입스크립트 둘 모두 타입을 알 수 없는 상황에서 any라고 추론하며, any는 가급적으로 사용하지 않아야 한다.

any 타입을 사용하면 자바스크립트처럼 동작하게 되며, 어떠한 연산자, 함수를 사용하더라도 컴파일 시, 에러가 발생하지 않는다.

### unknown

unknown 타입은 any 타입과 유사하게 동작하지만, 타입을 미리 알 수 없는 값이 있을 때, any로 선언하여 타입 안정성을 해치는 대신에 unknown으로 설정하고 refine할 때까지 unknown 타입의 값을 사용할 수 없도록 강제한다.

unknown은 지원하는 메서드는 없으며 비교와 반전 연산을 지원하고 typeof, instanceof 연산자로 정제(refine)할 수 있다.

타입스크립트는 unknown으로 타입 추론을 시도하지 않는다.
unknown 타입의 값은 특정 타입이라고 가정하고 동작하지 않는다.

위 특성으로 unknown은 any와 달리 type-safe 하다고 표현한다.

### boolean

boolean 타입은 true, false 두 개의 값을 가지고 비교와 반전 연산을 지원한다.

```typescript
let a = true // boolean
const c = true // true
let e: true = true // true
let f: true = false // Error
```

보통 (a, c)와 같은 형태로 사용하며 추가적인 타입 안정성을 얻기 위해 타입 리터럴을 사용하기도 한다.

### number

모든 숫자(정수, 소수, 양수, 음수, Infinity, NaN 등)을 포함하는 타입이며, 숫자 관련 연산을 지원한다.

보통 개발자들은 타입스크립트가 number을 추론하도록 아래와 같이 사용한다.
```typescript
let a = 343;
let b = Infinity \* 10;
```

number 타입임을 명시해야 하는 상황은 거의 없다.
```typescript
let e: number = 100;
```

### bigint

TypeScript 3.2 버전에서 추가된 타입니다.
number는 2^53 까지의 정수를 표현할 수 있지만, bigint는 이보다 큰 수도 표현이 가능하다.

연산과 메소드는 number와 유사하게 지원된다.

ECMAScript(js)에서 bigint와 number을 연산하면 에러가 발생하며,
<img width="690" alt="Screen Shot 2023-04-13 at 11 36 36 PM" src="https://user-images.githubusercontent.com/46529663/231794240-ec131311-7058-4fa3-a46a-c9a21073eb1f.png">

TypeScript에서도 bigint와 number 같의 연산을 지원하지 않는다.
<img width="800" alt="Screen Shot 2023-04-13 at 11 36 42 PM" src="https://user-images.githubusercontent.com/46529663/231794216-bbf91e80-0587-475d-9967-89fa0253885a.png">

bigint를 number로 변환할 때, 값을 잃을 수 있어서 유의해야 한다.
추가로, 정수형 타입으로 나누기(/) 연산 시 항상 소수점 이하를 버린다.

### string

모든 문자열의 집합

가능하다면 타입스크립트가 string 타입을 추론하도록 두는 것이 좋다.

### symbol

ES2015에 추가된 기능이다.

객체와 맵에서 문자열 키를 대신하는 용도로 사용된다.
객체의 반복자를 설정하거나, 객체가 어떤 인스턴스인지를 런타임에 오버라이딩하는 것과 비슷한 기능

symbol 타입 또한, 타입을 추론하게 두거나 특정한 symbol을 정의할 수 있다.

```typescript
const e = Symbol('e');
const f: unique symbol = Symbol('f');
```

자바스크립트에서 Symbol은 주어진 이름의 새로운 symbol을 만든다는 의미로, symbol은 unique한 특성을 가지기 때문에 == 또는 ===으로 비교했을 때 같지 않다고 판단한다.

### object

자바스크립트는 구조 기반 타입을 갖도록 설계되었기 때문에, 객체 타입만을 가지고 간단한 객체({})와 복잡한 객체를 구분할 수 없다.

타입스크립트도 이름 기반 타입 스타일 보다는 자바스크립트 스타일을 선호한다.

- Duck Typing : 객체의 변수 및 메서드의 집합이 객체의 타입을 결정하는 것을 의미. 동적 타이핑의 한 종류
- Structural Subtyping : 객체의 실제 구조나 정의에 따라 타입을 결정하는 것을 의미

타입스크립트에서 객체를 타입으로 선언하는 방식은 여러가지로
첫 번째는 object로 선언하는 것이다.

두 번째는 타입스크립트가 추론하도록 하는 방식이다.

타입스크립트가 객체 내부의 프로퍼티의 타입을 추론할 수 있도록 명시적으로 내부 프로퍼티에 타입을 명시할 수 있다.

타입스크립트는 객체 프로퍼티에 엄격한 편으로 b: number 프로퍼티가 기재되어 있을 경우, b가 없거나 다른 추가 프로퍼티가 있으면 에러를 발생시킨다.

이러한 경우 아래와 같이 프로퍼티를 추가할 수 있다.

```typescript
let obj: {
    b: number, // number 타입의 b 프로퍼티를 포함
    c? : string, // string 타입의 c 프로퍼티를 포함할 수도 있다.
    [key: number]: boolean // boolean 값을 갖는 number 타입 프로퍼티를 여러 개 포함할 수 있다.
}
```

- 객체 리터럴 표기법에는 빈 객체 타입이라는 방식도 있지만, 피하는 것이 좋다.
- Object 타입 또한, 가능한 사용하지 않아야 한다.

- 객체 정의 방법은 아래와 같다.
  - 객체 리터럴 또는 형태라 불리는 표기법: 객체가 어떤 필드를 가질 지 알고 있거나 객체의 모든 값이 같은 타입일 때, 사용한다.
  - 빈 객체 리터럴 표기법: 사용하지 않는 것이 좋다.
  - object 타입: 필드와 관계없이 객체가 필요할 때, 사용한다.
  - Object 타입: 사용하지 않는 것이 좋다.

### alias, union, intersection

- alias
  변수처럼 타입 별칭이라는 방식으로 타입을 가리킬 수 있다.

```typescript
type Age = number | string;
type Person = {
    name: string,
    age: Age
}
```

타입스크립트는 별칭을 추론하지 않으므로 별칭은 타입을 명시적으로 정의해야 한다.
Age는 number | string의 별칭으로 number 타입의 값도 할당할 수 있다.

---

- union & intersection
  합집합과 교집합을 뜻한다.

타입 스크립트는 유니온(|)과 인터섹션(&)을 제공한다.

타입은 집합과 유사하여 집합처럼 연산을 수행할 수 있다.

### array

자바스크립트처럼 연결, 삽입, 검색, 삭제 등을 지원하는 특별한 객체이다.

### tuple

배열의 서브타입으로 길이가 고정되어 있다.
다른 타입과 달리 튜플은 선언 시, 타입을 명시해야 한다.
이는, 자바스크립트에서 둘 모두 같은 문법을 사용하는데, 타입스크립트에서는 대괄호를 배열으로 추론하기 때문이다.

튜플은 객체 타입과 같이 선택형 요소도 지원한다.
`let metric: [number, number?][] = [[3.7], [3, 6.5]];`

스프레드(...) 또는 .slice 등으로 배열의 메서드를 사용할 때 우선 기존의 배열을 복사하므로, 이러한 부분은 주의하지 않으면 응용 프로그램의 성능이 느려질 수 있다.

### null, undefined, void, never

자바스크립트는 null, undefined의 값으로 부재를 표현한다.

- undefined는 아직 정의하지 않았음
- null은 값이 없다는 의미

- void는 아무것도 반환하지 않는 함수의 반환 타입
- never는 절대 반환하지 않는 함수 타입

### enum

해당 타입으로 사용할 수 있는 값을 열거하는 기법

키를 값에 할당하는 순서가 없는 자료구조, 키가 컴파일 타임에 고정된 객체
타입스크립트가 순서에 따라 숫자 값을 추론하지만, 직접 값을 설정해줄 수 있다.

const enum은 역방향 찾기를 지원하지 않으므로 열거형의 동작은 일반 자바스크립트 객체와 비슷해지며, 기본적으로 아무 자바스크립트를 생성하지 않고 해당 키의 값을 채워넣는다.

## 키워드

- 호환
- 정제
- Duck Typing : 객체의 변수 및 메서드의 집합이 객체의 타입을 결정하는 것을 의미. 동적 타이핑의 한 종류
- Structural Subtyping : 객체의 실제 구조나 정의에 따라 타입을 결정하는 것을 의미
- 타입 리터럴(type literal): 오직 하나의 값을 나타내는 타입
- let이냐 const이냐에 따라 타입스크립트가 추론하는 타입이 달라진다.
  - 이 타입 리터럴이라는 기능은 안정성을 추가로 확보하는 강력한 언어 기능이다.
- 일치 / 동등
- 타입스크립트가 타입을 추론하는 것을 선호하는 이유?
